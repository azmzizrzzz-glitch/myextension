file without edit
popup.js
async function updateStatus() {
    try {
        const data = await chrome.storage.local.get('extensionStatus');
        const status = data.extensionStatus;
        
        const statusBox = document.getElementById('statusBox');
        const statusText = document.getElementById('statusText');
        const toggleBtn = document.getElementById('toggleBtn');
        
        if (!status) {
            statusText.textContent = 'âŒ Ø§Ø¬Ø±Ø§ Ù†Ø´Ø¯Ù‡';
            statusText.className = 'status-text stopped';
            statusBox.className = 'status stopped';
            return;
        }
        
        if (status.isRunning) {
            statusText.textContent = 'âœ… Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§';
            statusText.className = 'status-text running';
            statusBox.className = 'status running';
            toggleBtn.textContent = 'â¸ï¸ Ù…ØªÙˆÙ‚Ù Ú©Ø±Ø¯Ù†';
            toggleBtn.className = 'btn btn-toggle';
        } else {
            statusText.textContent = 'â¸ï¸ Ù…ØªÙˆÙ‚Ù Ø´Ø¯Ù‡';
            statusText.className = 'status-text stopped';
            statusBox.className = 'status stopped';
            toggleBtn.textContent = 'â–¶ï¸ Ø´Ø±ÙˆØ¹ Ù…Ø¬Ø¯Ø¯';
            toggleBtn.className = 'btn btn-toggle stopped';
        }
        
    } catch (e) {
        console.log('Error:', e);
    }
}

document.getElementById('dashboardBtn').addEventListener('click', async () => {
    await chrome.runtime.sendMessage({ action: 'openDashboard' });
    window.close();
});

document.getElementById('toggleBtn').addEventListener('click', async () => {
    await chrome.runtime.sendMessage({ action: 'toggle' });
    updateStatus();
});

updateStatus();
setInterval(updateStatus, 2000);
//
popup.html
<!DOCTYPE html>
<html dir="rtl">
<head>
    <meta charset="UTF-8">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            width: 300px;
            font-family: Tahoma, Arial, sans-serif;
            background: #0a0a1a;
            color: #eee;
            padding: 20px;
            text-align: center;
        }
        
        h1 {
            color: #00ff88;
            font-size: 18px;
            margin-bottom: 20px;
        }
        
        .status {
            background: #1a1a2e;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .status.running {
            border: 2px solid #00ff88;
        }
        
        .status.stopped {
            border: 2px solid #ff4444;
        }
        
        .status-text {
            font-size: 16px;
            font-weight: bold;
        }
        
        .status-text.running {
            color: #00ff88;
        }
        
        .status-text.stopped {
            color: #ff4444;
        }
        
        .btn {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            border: none;
            border-radius: 8px;
            font-family: inherit;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn-dashboard {
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            color: #000;
        }
        
        .btn-dashboard:hover {
            transform: scale(1.02);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }
        
        .btn-toggle {
            background: #4dabf7;
            color: #000;
        }
        
        .btn-toggle.stopped {
            background: #ff4444;
            color: #fff;
        }
        
        .info {
            font-size: 11px;
            color: #888;
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <h1>ğŸ”Š Monitoring Alert</h1>
    
    <div class="status" id="statusBox">
        <div class="status-text" id="statusText">Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø±Ø±Ø³ÛŒ...</div>
    </div>
    
    <button class="btn btn-dashboard" id="dashboardBtn">
        ğŸ“Š Ø¨Ø§Ø² Ú©Ø±Ø¯Ù† Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ú©Ø§Ù…Ù„
    </button>
    
    <button class="btn btn-toggle" id="toggleBtn">
        â¸ï¸ Ù…ØªÙˆÙ‚Ù Ú©Ø±Ø¯Ù†
    </button>
    
    <div class="info">
        Ø¨Ø±Ø§ÛŒ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ø¬Ø²Ø¦ÛŒØ§Øª Ùˆ ØªÙ†Ø¸ÛŒÙ…Ø§ØªØŒ<br>
        Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ Ú©Ø§Ù…Ù„ Ø±Ø§ Ø¨Ø§Ø² Ú©Ù†ÛŒØ¯
    </div>
    
    <script src="popup.js"></script>
</body>
</html>
//
offscreen.js
// === Ù¾Ø®Ø´ ØµØ¯Ø§ ===
function playSound() {
    const audio = document.getElementById('alarmSound');
    if (audio) {
        audio.currentTime = 0;
        audio.play().catch(e => {
            // Ø§Ú¯Ø± ÙØ§ÛŒÙ„ mp3 Ù†Ø¨ÙˆØ¯ØŒ ØµØ¯Ø§ÛŒ beep Ø¨Ø³Ø§Ø²ÛŒÙ…
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 800;
            oscillator.type = 'square';
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            
            oscillator.start();
            setTimeout(() => oscillator.stop(), 500);
        });
    }
}

// === Ø¯Ø±ÛŒØ§ÙØª Ù¾ÛŒØ§Ù… ===
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    if (message.action === 'playSound') {
        playSound();
        sendResponse({ success: true });
    }
    return true;
});
//
offscreen.html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Offscreen Audio</title>
</head>
<body>
    <audio id="alarmSound" src="alarm.mp3" preload="auto"></audio>
    <script src="offscreen.js"></script>
</body>
</html>
//
offscreen.html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Offscreen Audio</title>
</head>
<body>
    <audio id="alarmSound" src="alarm.mp3" preload="auto"></audio>
    <script src="offscreen.js"></script>
</body>
</html>
//
icon.png nothing changed and its just png file
//
dashboard.html
<!DOCTYPE html>
<html dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>Monitoring Alert - Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Tahoma, Arial, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 100%);
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #333;
        }
        
        h1 {
            color: #00ff88;
            font-size: 24px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .header-buttons {
            display: flex;
            gap: 10px;
        }
        
        .status-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }
        
        .card {
            background: #1a1a2e;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
        }
        
        .card-label {
            color: #888;
            font-size: 12px;
            margin-bottom: 8px;
        }
        
        .card-value {
            font-size: 24px;
            font-weight: bold;
        }
        
        .card-value.running {
            color: #00ff88;
        }
        
        .card-value.stopped {
            color: #ff4444;
        }
        
        .card-value.number {
            color: #4dabf7;
        }
        
        h2 {
            color: #4dabf7;
            font-size: 16px;
            margin: 25px 0 15px 0;
            padding-bottom: 8px;
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn {
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            font-size: 13px;
            border: none;
            transition: all 0.3s;
        }
        
        .btn-toggle {
            background: #00ff88;
            color: #000;
        }
        
        .btn-toggle.stopped {
            background: #ff4444;
            color: #fff;
        }
        
        .btn-reset {
            background: linear-gradient(135deg, #ff6b6b, #ee5a5a);
            color: #fff;
        }
        
        .btn-reset:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.5);
        }
        
        .btn-clear {
            background: #666;
            color: #fff;
        }
        
        .btn:hover {
            opacity: 0.9;
            transform: translateY(-2px);
        }
        
        /* === ØªØ¨â€ŒÙ‡Ø§ === */
        .tab-item {
            background: #16213e;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            border-right: 5px solid #00ff88;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 15px;
        }
        
        .tab-item.alert {
            border-right-color: #ff4444;
            background: linear-gradient(135deg, #2a1a1a, #1a1a2e);
        }
        
        .tab-item.muted {
            opacity: 0.5;
            border-right-color: #666;
        }
        
        .tab-info {
            flex: 1;
        }
        
        .tab-title {
            font-size: 14px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .tab-details {
            font-size: 11px;
            color: #888;
            margin-bottom: 3px;
        }
        
        .tab-numbers {
            font-size: 11px;
            color: #4dabf7;
            margin-top: 5px;
        }
        
        .tab-alert-info {
            font-size: 11px;
            color: #ff4444;
            margin-top: 5px;
            background: rgba(255, 68, 68, 0.1);
            padding: 5px 8px;
            border-radius: 5px;
        }
        
        /* === Ø¯Ú©Ù…Ù‡ Mute === */
        .mute-toggle {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        .mute-btn {
            width: 60px;
            height: 30px;
            border-radius: 15px;
            border: none;
            cursor: pointer;
            position: relative;
            transition: all 0.3s;
        }
        
        .mute-btn.active {
            background: linear-gradient(135deg, #00ff88, #00cc6a);
        }
        
        .mute-btn.muted {
            background: linear-gradient(135deg, #666, #444);
        }
        
        .mute-btn::after {
            content: '';
            position: absolute;
            width: 24px;
            height: 24px;
            background: #fff;
            border-radius: 50%;
            top: 3px;
            transition: all 0.3s;
        }
        
        .mute-btn.active::after {
            right: 3px;
        }
        
        .mute-btn.muted::after {
            right: 33px;
        }
        
        .mute-label {
            font-size: 10px;
            color: #888;
        }
        
        .mute-label.active {
            color: #00ff88;
        }
        
        .mute-label.muted {
            color: #ff4444;
        }
        
        /* === Ø¢Ù„Ø§Ø±Ù…â€ŒÙ‡Ø§ === */
        .alert-item {
            background: #2a1a1a;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            border-right: 4px solid #ff4444;
        }
        
        .alert-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .alert-detail {
            font-size: 12px;
            color: #ff8888;
        }
        
        .alert-time {
            font-size: 10px;
            color: #888;
            margin-top: 5px;
        }
        
        .no-data {
            text-align: center;
            padding: 30px;
            color: #888;
        }
        
        .no-data.success {
            color: #00ff88;
        }
        
        /* === Ø§Ù†ÛŒÙ…ÛŒØ´Ù† === */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .alert-badge {
            display: inline-block;
            background: #ff4444;
            color: #fff;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            animation: pulse 1s infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ”Š Monitoring Alert</h1>
            <div class="header-buttons">
                <button class="btn btn-toggle" id="toggleBtn">â¸ï¸ Ù…ØªÙˆÙ‚Ù Ú©Ø±Ø¯Ù†</button>
                <button class="btn btn-reset" id="resetBtn">ğŸ”„ Ø±ÛŒØ³Øª Ú©Ø§Ù…Ù„</button>
            </div>
        </header>
        
        <div class="status-cards">
            <div class="card">
                <div class="card-label">ÙˆØ¶Ø¹ÛŒØª</div>
                <div class="card-value" id="statusText">-</div>
            </div>
            <div class="card">
                <div class="card-label">Ø²Ù…Ø§Ù† Ø´Ø±ÙˆØ¹</div>
                <div class="card-value number" id="startTime">-</div>
            </div>
            <div class="card">
                <div class="card-label">Ø¢Ø®Ø±ÛŒÙ† Ø¨Ø±Ø±Ø³ÛŒ</div>
                <div class="card-value number" id="lastCheck">-</div>
            </div>
            <div class="card">
                <div class="card-label">ØªØ¹Ø¯Ø§Ø¯ Ø¨Ø±Ø±Ø³ÛŒ</div>
                <div class="card-value number" id="totalChecks">0</div>
            </div>
        </div>
        
        <h2>ğŸ“‘ ØªØ¨â€ŒÙ‡Ø§ÛŒ ØªØ­Øª Ù†Ø¸Ø§Ø±Øª</h2>
        <div id="tabsList">
            <div class="no-data">Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ...</div>
        </div>
        
        <h2>
            ğŸš¨ Ø¢Ù„Ø§Ø±Ù…â€ŒÙ‡Ø§ÛŒ Ø§Ø®ÛŒØ±
            <button class="btn btn-clear" id="clearBtn">ğŸ—‘ï¸ Ù¾Ø§Ú© Ú©Ø±Ø¯Ù†</button>
        </h2>
        <div id="alertsList">
            <div class="no-data success">âœ… Ø¨Ø¯ÙˆÙ† Ø¢Ù„Ø§Ø±Ù…</div>
        </div>
    </div>
    
    <script src="dashboard.js"></script>
</body>
</html>
//
ok this 3 files is changed
new = manifest.json
{
  "manifest_version": 3,
  "name": "Monitoring Alert",
  "version": "2.0",
  "description": "Ø¢Ù„Ø§Ø±Ù… Ø¨Ø±Ø§ÛŒ Grafana Ùˆ Zabbix",
  "permissions": [
    "tabs",
    "scripting",
    "storage",
    "alarms",
    "offscreen"
  ],
  "host_permissions": [
    "<all_urls>"
  ],
  "background": {
    "service_worker": "background.js"
  },
  "action": {
    "default_popup": "popup.html",
    "default_icon": "icon.png"
  }
}
old = manifest.json
{
  "manifest_version": 3,
  "name": "Monitoring Alert",
  "version": "2.0",
  "description": "Ø¢Ù„Ø§Ø±Ù… ØµÙˆØªÛŒ Ø¨Ø±Ø§ÛŒ Ù…Ø§Ù†ÛŒØªÙˆØ±ÛŒÙ†Ú¯",
  "permissions": [
    "tabs",
    "scripting",
    "storage",
    "alarms",
    "offscreen"
  ],
  "host_permissions": [
    "<all_urls>"
  ],
  "background": {
    "service_worker": "background.js"
  },
  "action": {
    "default_popup": "popup.html",
    "default_icon": "icon.png"
  }
}
//
new = dashboard.js
const formatTime = (t) => t ? new Date(t).toLocaleTimeString('fa-IR') : '-';
const timeAgo = (t) => {
    if (!t) return '-';
    const s = Math.floor((Date.now() - t) / 1000);
    if (s < 60) return `${s} Ø«Ø§Ù†ÛŒÙ‡ Ù¾ÛŒØ´`;
    if (s < 3600) return `${Math.floor(s / 60)} Ø¯Ù‚ÛŒÙ‚Ù‡ Ù¾ÛŒØ´`;
    return `${Math.floor(s / 3600)} Ø³Ø§Ø¹Øª Ù¾ÛŒØ´`;
};

async function update() {
    const data = await chrome.storage.local.get('extensionStatus');
    const s = data.extensionStatus;
    
    if (!s) {
        document.getElementById('statusText').textContent = 'âŒ ØºÛŒØ±ÙØ¹Ø§Ù„';
        return;
    }
    
    const toggleBtn = document.getElementById('toggleBtn');
    if (s.isRunning) {
        document.getElementById('statusText').textContent = 'âœ… ÙØ¹Ø§Ù„';
        document.getElementById('statusText').className = 'card-value running';
        toggleBtn.textContent = 'â¸ï¸ Ù…ØªÙˆÙ‚Ù';
        toggleBtn.className = 'btn btn-toggle';
    } else {
        document.getElementById('statusText').textContent = 'â¸ï¸ Ù…ØªÙˆÙ‚Ù';
        document.getElementById('statusText').className = 'card-value stopped';
        toggleBtn.textContent = 'â–¶ï¸ Ø´Ø±ÙˆØ¹';
        toggleBtn.className = 'btn btn-toggle stopped';
    }
    
    document.getElementById('startTime').textContent = formatTime(s.startTime);
    document.getElementById('lastCheck').textContent = timeAgo(s.lastCheck);
    document.getElementById('totalChecks').textContent = s.totalChecks;
    
    // ØªØ¨â€ŒÙ‡Ø§
    const tabs = Object.entries(s.tabs || {});
    const tabsList = document.getElementById('tabsList');
    
    if (tabs.length === 0) {
        tabsList.innerHTML = '<div class="no-data">Ù‡Ù†ÙˆØ² ØªØ¨ÛŒ Ù†ÛŒØ³Øª</div>';
    } else {
        tabsList.innerHTML = tabs.map(([id, t]) => {
            const muted = s.mutedTabs && s.mutedTabs[id];
            const alert = t.status === 'ALERT';
            const typeClass = t.type === 'zabbix' ? 'type-zabbix' : 'type-grafana';
            const typeName = t.type === 'zabbix' ? 'Zabbix' : 'Grafana';
            
            let details = '';
            if (t.type === 'zabbix' && t.details) {
                details = `<div class="tab-details">Problems: ${t.details.totalProblems || 0} (Ù‡Ø´Ø¯Ø§Ø±: ${t.details.alertProblems || 0})</div>`;
                if (t.details.problems) {
                    t.details.problems.forEach(p => {
                        if (p.shouldAlert) {
                            details += `<div class="tab-alert">ğŸš¨ ${p.host}: ${p.problem} (${p.duration})</div>`;
                        }
                    });
                }
            } else if (t.type === 'grafana' && t.details) {
                details = `<div class="tab-details">Ø³Ø·Ø±Ù‡Ø§: ${t.details.recentRows || 0}</div>`;
                if (t.details.lastValue !== undefined) {
                    details += `<div class="tab-details">Ø¢Ø®Ø±ÛŒÙ†: ${t.details.lastValue}</div>`;
                }
                if (t.details.pageAlerts && t.details.pageAlerts.length > 0) {
                    details += `<div class="tab-alert">âš ï¸ ${t.details.pageAlerts.join(', ')}</div>`;
                }
            }
            
            return `
                <div class="tab-item ${alert ? 'alert' : ''} ${muted ? 'muted' : ''}">
                    <div class="tab-info">
                        <div class="tab-title">
                            <span class="type-badge ${typeClass}">${typeName}</span>
                            ${alert ? 'ğŸ”´' : 'ğŸŸ¢'} ${t.title}
                            ${muted ? '<span style="color:#888">(Ø¨ÛŒâ€ŒØµØ¯Ø§)</span>' : ''}
                        </div>
                        <div class="tab-details">Ø¢Ø®Ø±ÛŒÙ†: ${timeAgo(t.lastCheck)}</div>
                        ${details}
                    </div>
                    <div class="mute-toggle">
                        <button class="mute-btn ${muted ? 'muted' : 'active'}" data-id="${id}"></button>
                        <span class="mute-label ${muted ? 'muted' : 'active'}">${muted ? 'ğŸ”‡' : 'ğŸ”Š'}</span>
                    </div>
                </div>
            `;
        }).join('');
        
        document.querySelectorAll('.mute-btn').forEach(btn => {
            btn.onclick = async () => {
                await chrome.runtime.sendMessage({ action: 'toggleMute', tabId: parseInt(btn.dataset.id) });
                update();
            };
        });
    }
    
    // Ø¢Ù„Ø§Ø±Ù…â€ŒÙ‡Ø§
    const alerts = s.alerts || [];
    const alertsList = document.getElementById('alertsList');
    
    if (alerts.length === 0) {
        alertsList.innerHTML = '<div class="no-data ok">âœ… Ø¨Ø¯ÙˆÙ† Ø¢Ù„Ø§Ø±Ù…</div>';
    } else {
        alertsList.innerHTML = alerts.slice(0, 20).map(a => `
            <div class="alert-item">
                <div class="alert-title">ğŸš¨ ${a.tabTitle}</div>
                <div class="alert-detail">${a.detail}</div>
                <div class="alert-time">${formatTime(a.time)}</div>
            </div>
        `).join('');
    }
}

document.getElementById('toggleBtn').onclick = async () => {
    await chrome.runtime.sendMessage({ action: 'toggle' });
    update();
};

document.getElementById('resetBtn').onclick = async () => {
    if (confirm('Ø±ÛŒØ³Øª Ø´ÙˆØ¯ØŸ')) {
        await chrome.runtime.sendMessage({ action: 'reset' });
        update();
    }
};

document.getElementById('clearBtn').onclick = async () => {
    await chrome.runtime.sendMessage({ action: 'clearAlerts' });
    update();
};

update();
setInterval(update, 2000);
//
old = dashboard.js
function formatTime(timestamp) {
    if (!timestamp) return '-';
    const date = new Date(timestamp);
    return date.toLocaleTimeString('fa-IR');
}

function timeAgo(timestamp) {
    if (!timestamp) return '-';
    const seconds = Math.floor((Date.now() - timestamp) / 1000);
    
    if (seconds < 60) return `${seconds} Ø«Ø§Ù†ÛŒÙ‡ Ù¾ÛŒØ´`;
    if (seconds < 3600) return `${Math.floor(seconds / 60)} Ø¯Ù‚ÛŒÙ‚Ù‡ Ù¾ÛŒØ´`;
    return `${Math.floor(seconds / 3600)} Ø³Ø§Ø¹Øª Ù¾ÛŒØ´`;
}

async function updateDashboard() {
    try {
        const data = await chrome.storage.local.get('extensionStatus');
        const status = data.extensionStatus;
        
        if (!status) {
            document.getElementById('statusText').textContent = 'âŒ Ø§Ø¬Ø±Ø§ Ù†Ø´Ø¯Ù‡';
            document.getElementById('statusText').className = 'card-value stopped';
            return;
        }
        
        // === ÙˆØ¶Ø¹ÛŒØª ===
        const toggleBtn = document.getElementById('toggleBtn');
        if (status.isRunning) {
            document.getElementById('statusText').textContent = 'âœ… ÙØ¹Ø§Ù„';
            document.getElementById('statusText').className = 'card-value running';
            toggleBtn.textContent = 'â¸ï¸ Ù…ØªÙˆÙ‚Ù Ú©Ø±Ø¯Ù†';
            toggleBtn.className = 'btn btn-toggle';
        } else {
            document.getElementById('statusText').textContent = 'â¸ï¸ Ù…ØªÙˆÙ‚Ù';
            document.getElementById('statusText').className = 'card-value stopped';
            toggleBtn.textContent = 'â–¶ï¸ Ø´Ø±ÙˆØ¹ Ù…Ø¬Ø¯Ø¯';
            toggleBtn.className = 'btn btn-toggle stopped';
        }
        
        document.getElementById('startTime').textContent = formatTime(status.startTime);
        document.getElementById('lastCheck').textContent = timeAgo(status.lastCheck);
        document.getElementById('totalChecks').textContent = status.totalChecks;
        
        // === ØªØ¨â€ŒÙ‡Ø§ ===
        const tabsList = document.getElementById('tabsList');
        const tabs = Object.entries(status.tabs || {});
        
        if (tabs.length === 0) {
            tabsList.innerHTML = '<div class="no-data">Ù‡Ù†ÙˆØ² ØªØ¨ÛŒ Ø¨Ø±Ø±Ø³ÛŒ Ù†Ø´Ø¯Ù‡</div>';
        } else {
            tabsList.innerHTML = tabs.map(([tabId, tab]) => {
                const isMuted = status.mutedTabs && status.mutedTabs[tabId];
                const isAlert = tab.status === 'ALERT';
                
                return `
                <div class="tab-item ${isAlert ? 'alert' : ''} ${isMuted ? 'muted' : ''}">
                    <div class="tab-info">
                        <div class="tab-title">
                            ${isAlert ? 'ğŸ”´' : 'ğŸŸ¢'} ${tab.title}
                            ${isAlert && !isMuted ? '<span class="alert-badge">Ù‡Ø´Ø¯Ø§Ø±!</span>' : ''}
                            ${isMuted ? '<span style="color:#888;font-size:11px">(Ø¨ÛŒâ€ŒØµØ¯Ø§)</span>' : ''}
                        </div>
                        <div class="tab-details">Ø¢Ø®Ø±ÛŒÙ† Ø¨Ø±Ø±Ø³ÛŒ: ${timeAgo(tab.lastCheck)}</div>
                        <div class="tab-details">Ø³Ø·Ø±Ù‡Ø§: ${tab.recentRows || 0} (Ûµ Ø¯Ù‚ÛŒÙ‚Ù‡ Ø§Ø®ÛŒØ±)</div>
                        ${tab.lastValue !== null ? `
                            <div class="tab-numbers">
                                Ø¢Ø®Ø±ÛŒÙ† Ù…Ù‚Ø¯Ø§Ø±: <strong>${tab.lastValue}</strong>
                                ${tab.lastTime ? `(${tab.lastTime})` : ''}
                            </div>
                        ` : ''}
                        ${tab.average !== null ? `
                            <div class="tab-numbers">
                                Ù…ÛŒØ§Ù†Ú¯ÛŒÙ†: <strong>${tab.average.toFixed(2)}</strong>
                                (${tab.averageCount} Ù…Ù‚Ø¯Ø§Ø±)
                            </div>
                        ` : ''}
                        ${tab.pageAlertWords && tab.pageAlertWords.length > 0 ? `
                            <div class="tab-alert-info">
                                âš ï¸ ØµÙØ­Ù‡: ${tab.pageAlertWords.join(', ')}
                            </div>
                        ` : ''}
                        ${tab.alertWord ? `
                            <div class="tab-alert-info">
                                âš ï¸ Ø¬Ø¯ÙˆÙ„: ${tab.alertWord}
                            </div>
                        ` : ''}
                        ${tab.zeroValue ? `
                            <div class="tab-alert-info">
                                âš ï¸ Ù…Ù‚Ø¯Ø§Ø± ØµÙØ±!
                            </div>
                        ` : ''}
                        ${tab.suddenChange ? `
                            <div class="tab-alert-info">
                                âš ï¸ ${tab.suddenChange.direction} ${tab.suddenChange.change.toFixed(1)}%
                                (${tab.suddenChange.average.toFixed(1)} â†’ ${tab.suddenChange.current})
                            </div>
                        ` : ''}
                    </div>
                    <div class="mute-toggle">
                        <button class="mute-btn ${isMuted ? 'muted' : 'active'}" 
                                data-tab-id="${tabId}"
                                title="${isMuted ? 'ÙØ¹Ø§Ù„ Ú©Ø±Ø¯Ù† ØµØ¯Ø§' : 'Ø¨ÛŒâ€ŒØµØ¯Ø§ Ú©Ø±Ø¯Ù†'}">
                        </button>
                        <span class="mute-label ${isMuted ? 'muted' : 'active'}">
                            ${isMuted ? 'ğŸ”‡ Ø¨ÛŒâ€ŒØµØ¯Ø§' : 'ğŸ”Š ÙØ¹Ø§Ù„'}
                        </span>
                    </div>
                </div>
            `}).join('');
            
            // Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† event listener Ø¨Ø±Ø§ÛŒ Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ mute
            document.querySelectorAll('.mute-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const tabId = e.target.dataset.tabId;
                    await chrome.runtime.sendMessage({ 
                        action: 'toggleMute', 
                        tabId: parseInt(tabId) 
                    });
                    updateDashboard();
                });
            });
        }
        
        // === Ø¢Ù„Ø§Ø±Ù…â€ŒÙ‡Ø§ ===
        const alertsList = document.getElementById('alertsList');
        const alerts = status.alerts || [];
        
        if (alerts.length === 0) {
            alertsList.innerHTML = '<div class="no-data success">âœ… Ø¨Ø¯ÙˆÙ† Ø¢Ù„Ø§Ø±Ù…</div>';
        } else {
            alertsList.innerHTML = alerts.slice(0, 20).map(alert => `
                <div class="alert-item">
                    <div class="alert-title">ğŸš¨ ${alert.tabTitle}</div>
                    <div class="alert-detail">${alert.detail}</div>
                    <div class="alert-time">${formatTime(alert.time)}</div>
                </div>
            `).join('');
        }
        
    } catch (error) {
        console.log('Error:', error);
    }
}

// === Ø¯Ú©Ù…Ù‡ Toggle ===
document.getElementById('toggleBtn').addEventListener('click', async () => {
    await chrome.runtime.sendMessage({ action: 'toggle' });
    updateDashboard();
});

// === Ø¯Ú©Ù…Ù‡ Ø±ÛŒØ³Øª ===
document.getElementById('resetBtn').addEventListener('click', async () => {
    if (confirm('Ø¢ÛŒØ§ Ù…Ø·Ù…Ø¦Ù† Ù‡Ø³ØªÛŒØ¯ØŸ\nØªÙ…Ø§Ù… ØªØ¨â€ŒÙ‡Ø§ Ùˆ Ù„Ø§Ú¯â€ŒÙ‡Ø§ Ù¾Ø§Ú© Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯ Ùˆ Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø§Ø² Ø§ÙˆÙ„ Ø´Ø±ÙˆØ¹ Ù…ÛŒâ€ŒÚ©Ù†Ø¯.')) {
        await chrome.runtime.sendMessage({ action: 'reset' });
        updateDashboard();
    }
});

// === Ø¯Ú©Ù…Ù‡ Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ø¢Ù„Ø§Ø±Ù…â€ŒÙ‡Ø§ ===
document.getElementById('clearBtn').addEventListener('click', async () => {
    await chrome.runtime.sendMessage({ action: 'clearAlerts' });
    updateDashboard();
});

// === Ø´Ø±ÙˆØ¹ ===
updateDashboard();
setInterval(updateDashboard, 2000);
//
new = background.js
// === ØªÙ†Ø¸ÛŒÙ…Ø§Øª ===
const CHECK_INTERVAL = 3000;
const HISTORY_MINUTES = 5;
const CHANGE_THRESHOLD = 50;
const ZABBIX_MIN_MINUTES = 5;
const ZABBIX_MAX_MINUTES = 10;
let isRunning = true;

// === Ú©Ù„Ù…Ø§Øª Ø®Ø·Ø±Ù†Ø§Ú© ===
const ALERT_PATTERNS = [
    /\bDOWN\b/i, /\bDisconnect\b/i, /\bDisconnected\b/i,
    /\bError\b/i, /\bCritical\b/i, /\bFailed\b/i,
    /\bFailure\b/i, /\bUnreachable\b/i, /\bOffline\b/i, /\bTimeout\b/i
];
const SAFE_WORDS = ['download', 'dropdown', 'markdown', 'breakdown'];

// === Ø°Ø®ÛŒØ±Ù‡ ÙˆØ¶Ø¹ÛŒØª ===
let extensionStatus = {
    isRunning: true,
    startTime: Date.now(),
    lastCheck: null,
    totalChecks: 0,
    tabs: {},
    alerts: [],
    mutedTabs: {}
};

// === Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ÙˆØ¶Ø¹ÛŒØª ===
async function loadStatus() {
    try {
        const data = await chrome.storage.local.get('extensionStatus');
        if (data.extensionStatus) {
            extensionStatus = { ...extensionStatus, ...data.extensionStatus };
            isRunning = extensionStatus.isRunning;
        }
    } catch (e) {}
}

// === Ø°Ø®ÛŒØ±Ù‡ ÙˆØ¶Ø¹ÛŒØª ===
async function saveStatus() {
    await chrome.storage.local.set({ extensionStatus });
}

// === Ù¾Ø®Ø´ ØµØ¯Ø§ ===
async function setupOffscreen() {
    try {
        const contexts = await chrome.runtime.getContexts({
            contextTypes: ['OFFSCREEN_DOCUMENT']
        });
        if (contexts.length === 0) {
            await chrome.offscreen.createDocument({
                url: 'offscreen.html',
                reasons: ['AUDIO_PLAYBACK'],
                justification: 'Ù¾Ø®Ø´ Ø¢Ù„Ø§Ø±Ù…'
            });
        }
    } catch (e) {}
}

async function playAlarm() {
    try {
        await setupOffscreen();
        await chrome.runtime.sendMessage({ action: 'playSound' });
    } catch (e) {}
}

// === Ø®ÙˆØ§Ù†Ø¯Ù† Grafana ===
function readGrafana() {
    const result = { type: 'grafana', rows: [], pageAlerts: [], error: null };
    
    try {
        // Ø¬Ø³ØªØ¬ÙˆÛŒ Ú©Ù„ ØµÙØ­Ù‡
        const safeWords = ['download', 'dropdown', 'markdown', 'breakdown'];
        const alertPatterns = [
            /\bDOWN\b/gi, /\bDisconnect\b/gi, /\bDisconnected\b/gi,
            /\bError\b/gi, /\bCritical\b/gi, /\bFailed\b/gi,
            /\bFailure\b/gi, /\bUnreachable\b/gi, /\bOffline\b/gi, /\bTimeout\b/gi
        ];
        
        let pageText = document.body.innerText || '';
        for (let word of safeWords) {
            pageText = pageText.replace(new RegExp(word, 'gi'), '___');
        }
        
        for (let pattern of alertPatterns) {
            const matches = pageText.match(pattern);
            if (matches) {
                matches.forEach(m => {
                    if (!result.pageAlerts.includes(m.toUpperCase())) {
                        result.pageAlerts.push(m.toUpperCase());
                    }
                });
            }
        }
        
        // Ø®ÙˆØ§Ù†Ø¯Ù† Ø¬Ø¯ÙˆÙ„
        const rows = document.querySelectorAll('[role="row"]');
        for (let row of rows) {
            const cells = row.querySelectorAll('[role="cell"]');
            if (cells.length >= 2) {
                const timeText = cells[0].innerText.trim();
                const valueText = cells[1].innerText.trim();
                const timeMatch = timeText.match(/(\d{4}-\d{2}-\d{2})\s+(\d{2}:\d{2}:\d{2})/);
                
                if (timeMatch) {
                    const timestamp = new Date(timeMatch[1] + 'T' + timeMatch[2]).getTime();
                    const numValue = parseFloat(valueText);
                    result.rows.push({
                        timestamp, timeText,
                        value: isNaN(numValue) ? valueText : numValue,
                        isNumeric: !isNaN(numValue)
                    });
                }
            }
        }
        result.rows.sort((a, b) => a.timestamp - b.timestamp);
    } catch (e) {
        result.error = e.message;
    }
    
    return result;
}

// === Ø®ÙˆØ§Ù†Ø¯Ù† Zabbix ===
function readZabbix() {
    const result = { type: 'zabbix', problems: [], error: null };
    
    try {
        const tables = document.querySelectorAll('table');
        const seen = new Set();
        
        tables.forEach((table) => {
            const rows = table.querySelectorAll('tbody tr');
            
            rows.forEach((row) => {
                const cells = row.querySelectorAll('td');
                if (cells.length < 7) return;
                
                const rowText = row.innerText.toLowerCase();
                if (rowText.includes('resolved')) return;
                
                const time = cells[0]?.innerText?.trim() || '';
                const host = cells[4]?.innerText?.trim() || '';
                const problem = cells[5]?.innerText?.trim() || '';
                const duration = cells[6]?.innerText?.trim() || '';
                
                if (!duration || !problem) return;
                
                const key = `${host}-${problem}`;
                if (seen.has(key)) return;
                seen.add(key);
                
                // ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ Ø¯Ù‚ÛŒÙ‚Ù‡
                let minutes = 0;
                const h = duration.match(/(\d+)h/);
                const m = duration.match(/(\d+)m/);
                const s = duration.match(/(\d+)s/);
                if (h) minutes += parseInt(h[1]) * 60;
                if (m) minutes += parseInt(m[1]);
                if (s) minutes += parseInt(s[1]) / 60;
                
                result.problems.push({
                    time, host, problem, duration, minutes,
                    shouldAlert: minutes >= 5 && minutes <= 10
                });
            });
        });
    } catch (e) {
        result.error = e.message;
    }
    
    return result;
}

// === ØªØ´Ø®ÛŒØµ Ù†ÙˆØ¹ ØµÙØ­Ù‡ Ùˆ Ø®ÙˆØ§Ù†Ø¯Ù† ===
function detectAndRead() {
    const url = window.location.href.toLowerCase();
    const html = document.body.innerHTML.toLowerCase();
    
    if (url.includes('zabbix') || html.includes('zabbix')) {
        return readZabbix();
    } else if (url.includes('grafana') || html.includes('grafana')) {
        return readGrafana();
    }
    
    // ØªÙ„Ø§Ø´ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ø¯Ùˆ
    const zabbix = readZabbix();
    if (zabbix.problems.length > 0) return zabbix;
    
    return readGrafana();
}

// === Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† ===
function calculateAverage(arr) {
    if (arr.length === 0) return 0;
    return arr.reduce((a, b) => a + b, 0) / arr.length;
}

// === Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù†ØªØ§ÛŒØ¬ ===
async function processResults(data, tab) {
    const now = Date.now();
    const tabId = tab.id;
    const isMuted = extensionStatus.mutedTabs[tabId] === true;
    
    extensionStatus.tabs[tabId] = {
        title: tab.title,
        url: tab.url,
        type: data.type,
        lastCheck: now,
        status: 'OK',
        isMuted,
        details: {}
    };
    
    let shouldAlarm = false;
    let alertReasons = [];
    
    // === Ù¾Ø±Ø¯Ø§Ø²Ø´ Zabbix ===
    if (data.type === 'zabbix') {
        const alertProblems = data.problems.filter(p => p.shouldAlert);
        extensionStatus.tabs[tabId].details = {
            totalProblems: data.problems.length,
            alertProblems: alertProblems.length,
            problems: data.problems
        };
        
        if (alertProblems.length > 0 && !isMuted) {
            extensionStatus.tabs[tabId].status = 'ALERT';
            shouldAlarm = true;
            alertReasons.push(`Zabbix: ${alertProblems.length} Ù…Ø´Ú©Ù„ (Ûµ-Û±Û° Ø¯Ù‚ÛŒÙ‚Ù‡)`);
        }
    }
    
    // === Ù¾Ø±Ø¯Ø§Ø²Ø´ Grafana ===
    if (data.type === 'grafana') {
        const fiveMinutesAgo = now - (HISTORY_MINUTES * 60 * 1000);
        const recentRows = data.rows.filter(r => r.timestamp >= fiveMinutesAgo);
        
        extensionStatus.tabs[tabId].details = {
            totalRows: data.rows.length,
            recentRows: recentRows.length,
            pageAlerts: data.pageAlerts
        };
        
        // Ú©Ù„Ù…Ø§Øª Ø®Ø·Ø±Ù†Ø§Ú© Ø¯Ø± ØµÙØ­Ù‡
        if (data.pageAlerts.length > 0 && !isMuted) {
            extensionStatus.tabs[tabId].status = 'ALERT';
            shouldAlarm = true;
            alertReasons.push(`ØµÙØ­Ù‡: ${data.pageAlerts.join(', ')}`);
        }
        
        if (recentRows.length > 0) {
            const latest = recentRows[recentRows.length - 1];
            extensionStatus.tabs[tabId].details.lastValue = latest.value;
            extensionStatus.tabs[tabId].details.lastTime = latest.timeText;
            
            // Ù…Ù‚Ø¯Ø§Ø± ØµÙØ±
            if (latest.isNumeric && latest.value === 0 && !isMuted) {
                extensionStatus.tabs[tabId].status = 'ALERT';
                shouldAlarm = true;
                alertReasons.push('Ù…Ù‚Ø¯Ø§Ø± = Û°');
            }
            
            // Ú©Ø§Ù‡Ø´ ÛµÛ°Ùª
            if (latest.isNumeric && recentRows.length >= 3) {
                const prevNums = recentRows.slice(0, -1).filter(r => r.isNumeric).map(r => r.value);
                if (prevNums.length >= 2) {
                    const avg = calculateAverage(prevNums);
                    extensionStatus.tabs[tabId].details.average = avg;
                    
                    if (avg > 0) {
                        const change = ((avg - latest.value) / avg) * 100;
                        if (change >= CHANGE_THRESHOLD && !isMuted) {
                            extensionStatus.tabs[tabId].status = 'ALERT';
                            shouldAlarm = true;
                            alertReasons.push(`Ú©Ø§Ù‡Ø´ ${change.toFixed(1)}%`);
                        }
                    }
                }
            }
        }
    }
    
    // Ø«Ø¨Øª Ø¢Ù„Ø§Ø±Ù…
    if (shouldAlarm) {
        extensionStatus.alerts.unshift({
            time: now,
            tabId,
            tabTitle: tab.title,
            type: data.type,
            detail: alertReasons.join(' + ')
        });
        if (extensionStatus.alerts.length > 50) {
            extensionStatus.alerts = extensionStatus.alerts.slice(0, 50);
        }
        await playAlarm();
    }
}

// === Ø¨Ø±Ø±Ø³ÛŒ ÛŒÚ© ØªØ¨ ===
async function checkTab(tab) {
    if (!tab.url) return;
    if (tab.url.startsWith('chrome://')) return;
    if (tab.url.startsWith('chrome-extension://')) return;
    
    try {
        const results = await chrome.scripting.executeScript({
            target: { tabId: tab.id },
            func: detectAndRead
        });
        
        if (results && results[0] && results[0].result) {
            await processResults(results[0].result, tab);
        }
    } catch (e) {}
}

// === Ø¨Ø±Ø±Ø³ÛŒ Ù‡Ù…Ù‡ ØªØ¨â€ŒÙ‡Ø§ ===
async function checkAllTabs() {
    if (!isRunning) return;
    
    extensionStatus.lastCheck = Date.now();
    extensionStatus.totalChecks++;
    extensionStatus.isRunning = isRunning;
    
    try {
        const tabs = await chrome.tabs.query({});
        for (let tab of tabs) {
            await checkTab(tab);
        }
        await saveStatus();
    } catch (e) {}
}

// === Ø±ÛŒØ³Øª ===
function resetAll() {
    extensionStatus = {
        isRunning: true,
        startTime: Date.now(),
        lastCheck: null,
        totalChecks: 0,
        tabs: {},
        alerts: [],
        mutedTabs: {}
    };
    isRunning = true;
    saveStatus();
}

// === Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ ===
chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
    if (msg.action === 'toggle') {
        isRunning = !isRunning;
        extensionStatus.isRunning = isRunning;
        saveStatus();
        sendResponse({ isRunning });
    } else if (msg.action === 'reset') {
        resetAll();
        sendResponse({ success: true });
    } else if (msg.action === 'clearAlerts') {
        extensionStatus.alerts = [];
        saveStatus();
        sendResponse({ success: true });
    } else if (msg.action === 'toggleMute') {
        extensionStatus.mutedTabs[msg.tabId] = !extensionStatus.mutedTabs[msg.tabId];
        saveStatus();
        sendResponse({ isMuted: extensionStatus.mutedTabs[msg.tabId] });
    } else if (msg.action === 'openDashboard') {
        chrome.tabs.create({ url: 'dashboard.html' });
        sendResponse({ success: true });
    }
    return true;
});

// === Alarm ===
chrome.alarms.create('check', { periodInMinutes: 0.05 });
chrome.alarms.onAlarm.addListener((alarm) => {
    if (alarm.name === 'check') checkAllTabs();
});

// === Keep-alive ===
setInterval(() => chrome.runtime.getPlatformInfo(() => {}), 20000);

// === Ø´Ø±ÙˆØ¹ ===
console.log('ğŸš€ Monitoring Alert v2.0');
loadStatus().then(() => {
    setupOffscreen();
    checkAllTabs();
}); 
old = background.js
// === ØªÙ†Ø¸ÛŒÙ…Ø§Øª ===
const CHECK_INTERVAL_MINUTES = 0.05; // 3 Ø«Ø§Ù†ÛŒÙ‡
const HISTORY_MINUTES = 5;
const CHANGE_THRESHOLD = 50;
let isRunning = true;

// === Ú©Ù„Ù…Ø§Øª Ø®Ø·Ø±Ù†Ø§Ú© ===
const ALERT_PATTERNS = [
    /\bDOWN\b/i,
    /\bDisconnect\b/i,
    /\bDisconnected\b/i,
    /\bError\b/i,
    /\bCritical\b/i,
    /\bFailed\b/i,
    /\bFailure\b/i,
    /\bUnreachable\b/i,
    /\bOffline\b/i,
    /\bTimeout\b/i
];

// === Ú©Ù„Ù…Ø§Øª Ø§Ù…Ù† ===
const SAFE_WORDS = ['download', 'dropdown', 'markdown', 'breakdown'];

// === Ø°Ø®ÛŒØ±Ù‡ ÙˆØ¶Ø¹ÛŒØª ===
let extensionStatus = {
    isRunning: true,
    startTime: Date.now(),
    lastCheck: null,
    totalChecks: 0,
    tabs: {},
    alerts: [],
    mutedTabs: {}  // â—„â”€â”€ Ø¬Ø¯ÛŒØ¯: ØªØ¨â€ŒÙ‡Ø§ÛŒ mute Ø´Ø¯Ù‡
};

// === Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ÙˆØ¶Ø¹ÛŒØª Ø§Ø² storage ===
async function loadStatus() {
    try {
        const data = await chrome.storage.local.get('extensionStatus');
        if (data.extensionStatus) {
            extensionStatus = { ...extensionStatus, ...data.extensionStatus };
            isRunning = extensionStatus.isRunning;
        }
    } catch (e) {}
}

// === Ø°Ø®ÛŒØ±Ù‡ ÙˆØ¶Ø¹ÛŒØª ===
async function saveStatus() {
    await chrome.storage.local.set({ extensionStatus });
}

// === Ø§ÛŒØ¬Ø§Ø¯ offscreen document Ø¨Ø±Ø§ÛŒ Ù¾Ø®Ø´ ØµØ¯Ø§ ===
async function setupOffscreen() {
    try {
        const existingContexts = await chrome.runtime.getContexts({
            contextTypes: ['OFFSCREEN_DOCUMENT']
        });
        
        if (existingContexts.length === 0) {
            await chrome.offscreen.createDocument({
                url: 'offscreen.html',
                reasons: ['AUDIO_PLAYBACK'],
                justification: 'Ù¾Ø®Ø´ Ø¢Ù„Ø§Ø±Ù… ØµÙˆØªÛŒ'
            });
        }
    } catch (e) {
        console.log('Offscreen setup error:', e);
    }
}

// === Ù¾Ø®Ø´ ØµØ¯Ø§ ===
async function playAlarm() {
    try {
        await setupOffscreen();
        await chrome.runtime.sendMessage({ action: 'playSound' });
    } catch (e) {
        console.log('Alarm error:', e);
    }
}

// === Ø®ÙˆØ§Ù†Ø¯Ù† Ø¬Ø¯ÙˆÙ„ Grafana ===
function readGrafanaTable() {
    const result = {
        rows: [],
        error: null
    };
    
    try {
        const rowElements = document.querySelectorAll('[role="row"]');
        
        for (let row of rowElements) {
            const cells = row.querySelectorAll('[role="cell"]');
            
            if (cells.length >= 2) {
                const timeText = cells[0].innerText.trim();
                const valueText = cells[1].innerText.trim();
                
                const timeMatch = timeText.match(/(\d{4}-\d{2}-\d{2})\s+(\d{2}:\d{2}:\d{2})/);
                
                if (timeMatch) {
                    const timestamp = new Date(timeMatch[1] + 'T' + timeMatch[2]).getTime();
                    const numValue = parseFloat(valueText);
                    
                    result.rows.push({
                        timestamp: timestamp,
                        timeText: timeText,
                        value: isNaN(numValue) ? valueText : numValue,
                        isNumeric: !isNaN(numValue)
                    });
                }
            }
        }
        
        result.rows.sort((a, b) => a.timestamp - b.timestamp);
        
    } catch (e) {
        result.error = e.message;
    }
    
    return result;
}

// === Ø¬Ø³ØªØ¬ÙˆÛŒ Ú©Ù„ ØµÙØ­Ù‡ Ø¨Ø±Ø§ÛŒ Ú©Ù„Ù…Ø§Øª Ø®Ø·Ø±Ù†Ø§Ú© ===
function scanFullPage() {
    const result = {
        foundWords: [],
        error: null
    };
    
    try {
        const safeWords = ['download', 'dropdown', 'markdown', 'breakdown'];
        const alertPatterns = [
            /\bDOWN\b/gi,
            /\bDisconnect\b/gi,
            /\bDisconnected\b/gi,
            /\bError\b/gi,
            /\bCritical\b/gi,
            /\bFailed\b/gi,
            /\bFailure\b/gi,
            /\bUnreachable\b/gi,
            /\bOffline\b/gi,
            /\bTimeout\b/gi
        ];
        
        let pageText = document.body.innerText || '';
        
        for (let word of safeWords) {
            pageText = pageText.replace(new RegExp(word, 'gi'), '___SAFE___');
        }
        
        for (let pattern of alertPatterns) {
            const matches = pageText.match(pattern);
            if (matches) {
                for (let match of matches) {
                    if (!result.foundWords.includes(match.toUpperCase())) {
                        result.foundWords.push(match.toUpperCase());
                    }
                }
            }
        }
        
    } catch (e) {
        result.error = e.message;
    }
    
    return result;
}

// === Ø­Ø°Ù Ú©Ù„Ù…Ø§Øª Ø§Ù…Ù† ===
function removeSafeWords(text) {
    let cleanText = text.toLowerCase();
    for (let word of SAFE_WORDS) {
        cleanText = cleanText.replace(new RegExp(word, 'gi'), '___');
    }
    return cleanText;
}

// === Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù„Ù…Ø§Øª Ø®Ø·Ø±Ù†Ø§Ú© ===
function checkAlertPatterns(text) {
    const cleanText = removeSafeWords(text);
    for (let pattern of ALERT_PATTERNS) {
        if (pattern.test(cleanText)) {
            const match = cleanText.match(pattern);
            return match ? match[0].toUpperCase() : 'ALERT';
        }
    }
    return null;
}

// === Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† ===
function calculateAverage(arr) {
    if (arr.length === 0) return 0;
    return arr.reduce((a, b) => a + b, 0) / arr.length;
}

// === Ø¨Ø±Ø±Ø³ÛŒ ÛŒÚ© ØªØ¨ ===
async function checkTab(tab) {
    if (!tab.url) return;
    if (tab.url.startsWith('chrome://')) return;
    if (tab.url.startsWith('chrome-extension://')) return;
    
    // Ø¨Ø±Ø±Ø³ÛŒ mute
    const isMuted = extensionStatus.mutedTabs[tab.id] === true;
    
    try {
        const tableResults = await chrome.scripting.executeScript({
            target: { tabId: tab.id },
            func: readGrafanaTable
        });
        
        const pageResults = await chrome.scripting.executeScript({
            target: { tabId: tab.id },
            func: scanFullPage
        });
        
        const now = Date.now();
        
        extensionStatus.tabs[tab.id] = {
            title: tab.title,
            url: tab.url,
            lastCheck: now,
            status: 'OK',
            totalRows: 0,
            recentRows: 0,
            lastValue: null,
            lastTime: null,
            average: null,
            averageCount: 0,
            alertWord: null,
            pageAlertWords: [],
            suddenChange: null,
            zeroValue: false,
            isMuted: isMuted  // â—„â”€â”€ Ø¬Ø¯ÛŒØ¯
        };
        
        let shouldAlarm = false;
        let alertReasons = [];
        
        // === Check 1: Ú©Ù„Ù…Ø§Øª Ø®Ø·Ø±Ù†Ø§Ú© Ø¯Ø± Ú©Ù„ ØµÙØ­Ù‡ ===
        if (pageResults && pageResults[0] && pageResults[0].result) {
            const pageData = pageResults[0].result;
            if (pageData.foundWords && pageData.foundWords.length > 0) {
                extensionStatus.tabs[tab.id].status = 'ALERT';
                extensionStatus.tabs[tab.id].pageAlertWords = pageData.foundWords;
                if (!isMuted) {
                    shouldAlarm = true;
                    alertReasons.push(`ØµÙØ­Ù‡: ${pageData.foundWords.join(', ')}`);
                }
            }
        }
        
        if (!tableResults || !tableResults[0] || !tableResults[0].result) {
            if (shouldAlarm && !isMuted) {
                extensionStatus.alerts.unshift({
                    time: now,
                    tabTitle: tab.title,
                    tabId: tab.id,
                    detail: alertReasons.join(' + ')
                });
                if (extensionStatus.alerts.length > 50) {
                    extensionStatus.alerts = extensionStatus.alerts.slice(0, 50);
                }
                await playAlarm();
            }
            return;
        }
        
        const data = tableResults[0].result;
        const fiveMinutesAgo = now - (HISTORY_MINUTES * 60 * 1000);
        const recentRows = data.rows.filter(row => row.timestamp >= fiveMinutesAgo);
        
        extensionStatus.tabs[tab.id].totalRows = data.rows.length;
        extensionStatus.tabs[tab.id].recentRows = recentRows.length;
        
        if (recentRows.length === 0) {
            if (shouldAlarm && !isMuted) {
                extensionStatus.alerts.unshift({
                    time: now,
                    tabTitle: tab.title,
                    tabId: tab.id,
                    detail: alertReasons.join(' + ')
                });
                if (extensionStatus.alerts.length > 50) {
                    extensionStatus.alerts = extensionStatus.alerts.slice(0, 50);
                }
                await playAlarm();
            }
            return;
        }
        
        const latestRow = recentRows[recentRows.length - 1];
        extensionStatus.tabs[tab.id].lastValue = latestRow.value;
        extensionStatus.tabs[tab.id].lastTime = latestRow.timeText;
        
        // === Check 2: Ú©Ù„Ù…Ø§Øª Ø®Ø·Ø±Ù†Ø§Ú© Ø¯Ø± Ø¬Ø¯ÙˆÙ„ ===
        if (!latestRow.isNumeric) {
            const foundWord = checkAlertPatterns(String(latestRow.value));
            if (foundWord) {
                extensionStatus.tabs[tab.id].status = 'ALERT';
                extensionStatus.tabs[tab.id].alertWord = foundWord;
                if (!isMuted) {
                    shouldAlarm = true;
                    alertReasons.push(`Ø¬Ø¯ÙˆÙ„: "${foundWord}"`);
                }
            }
        }
        
        // === Check 3: Ù…Ù‚Ø¯Ø§Ø± ØµÙØ± ===
        if (latestRow.isNumeric && latestRow.value === 0) {
            extensionStatus.tabs[tab.id].status = 'ALERT';
            extensionStatus.tabs[tab.id].zeroValue = true;
            if (!isMuted) {
                shouldAlarm = true;
                alertReasons.push('Ù…Ù‚Ø¯Ø§Ø± = Û°');
            }
        }
        
        // === Check 4: Ú©Ø§Ù‡Ø´ Ø¨ÛŒØ´ Ø§Ø² ÛµÛ°Ùª ===
        if (latestRow.isNumeric && recentRows.length >= 3) {
            const previousNumeric = recentRows
                .slice(0, -1)
                .filter(r => r.isNumeric)
                .map(r => r.value);
            
            if (previousNumeric.length >= 2) {
                const average = calculateAverage(previousNumeric);
                
                extensionStatus.tabs[tab.id].average = average;
                extensionStatus.tabs[tab.id].averageCount = previousNumeric.length;
                
                if (average > 0) {
                    const changePercent = ((average - latestRow.value) / average) * 100;
                    
                    if (changePercent >= CHANGE_THRESHOLD) {
                        extensionStatus.tabs[tab.id].status = 'ALERT';
                        extensionStatus.tabs[tab.id].suddenChange = {
                            average: average,
                            current: latestRow.value,
                            change: changePercent,
                            direction: 'Ú©Ø§Ù‡Ø´'
                        };
                        if (!isMuted) {
                            shouldAlarm = true;
                            alertReasons.push(`Ú©Ø§Ù‡Ø´ ${changePercent.toFixed(1)}%`);
                        }
                    }
                }
            }
        }
        
        // === Ø«Ø¨Øª Ø¢Ù„Ø§Ø±Ù… ===
        if (shouldAlarm && !isMuted) {
            extensionStatus.alerts.unshift({
                time: now,
                tabTitle: tab.title,
                tabId: tab.id,
                detail: alertReasons.join(' + ')
            });
            
            if (extensionStatus.alerts.length > 50) {
                extensionStatus.alerts = extensionStatus.alerts.slice(0, 50);
            }
            
            await playAlarm();
        }
        
    } catch (e) {
        console.log('Check tab error:', e);
    }
}

// === Ø¨Ø±Ø±Ø³ÛŒ Ù‡Ù…Ù‡ ØªØ¨â€ŒÙ‡Ø§ ===
async function checkAllTabs() {
    if (!isRunning) return;
    
    extensionStatus.lastCheck = Date.now();
    extensionStatus.totalChecks++;
    extensionStatus.isRunning = isRunning;
    
    try {
        const tabs = await chrome.tabs.query({});
        for (let tab of tabs) {
            await checkTab(tab);
        }
        await saveStatus();
    } catch (e) {
        console.log('Check all tabs error:', e);
    }
}

// === Ø±ÛŒØ³Øª Ú©Ø§Ù…Ù„ ===
function resetAll() {
    extensionStatus = {
        isRunning: true,
        startTime: Date.now(),
        lastCheck: null,
        totalChecks: 0,
        tabs: {},
        alerts: [],
        mutedTabs: {}
    };
    isRunning = true;
    saveStatus();
    checkAllTabs();
}

// === Ø¯Ø±ÛŒØ§ÙØª Ù¾ÛŒØ§Ù… ===
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    if (message.action === 'toggle') {
        isRunning = !isRunning;
        extensionStatus.isRunning = isRunning;
        saveStatus();
        sendResponse({ isRunning });
    } else if (message.action === 'clearAlerts') {
        extensionStatus.alerts = [];
        saveStatus();
        sendResponse({ success: true });
    } else if (message.action === 'reset') {
        resetAll();
        sendResponse({ success: true });
    } else if (message.action === 'toggleMute') {
        const tabId = message.tabId;
        extensionStatus.mutedTabs[tabId] = !extensionStatus.mutedTabs[tabId];
        if (extensionStatus.tabs[tabId]) {
            extensionStatus.tabs[tabId].isMuted = extensionStatus.mutedTabs[tabId];
        }
        saveStatus();
        sendResponse({ isMuted: extensionStatus.mutedTabs[tabId] });
    } else if (message.action === 'getStatus') {
        sendResponse({ extensionStatus });
    } else if (message.action === 'openDashboard') {
        chrome.tabs.create({ url: 'dashboard.html' });
        sendResponse({ success: true });
    }
    return true;
});

// === Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² chrome.alarms ===
chrome.alarms.create('checkTabs', { 
    delayInMinutes: CHECK_INTERVAL_MINUTES,
    periodInMinutes: CHECK_INTERVAL_MINUTES
});

chrome.alarms.onAlarm.addListener((alarm) => {
    if (alarm.name === 'checkTabs') {
        checkAllTabs();
    }
});

// === Keep-alive ===
const keepAlive = () => {
    chrome.runtime.getPlatformInfo(() => {});
};
setInterval(keepAlive, 20000);

// === Ø´Ø±ÙˆØ¹ ===
console.log('ğŸš€ Monitoring Alert v2.0 Ø´Ø±ÙˆØ¹ Ø´Ø¯!');
loadStatus().then(() => {
    setupOffscreen();
    checkAllTabs();
});
